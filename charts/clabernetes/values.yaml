---
#
# global options
#
# note the yaml anchors, we use these to easily pass the same values to the clicker sub-chart (if
# enabling); there is no magic here other than yaml anchor magic, if you expect the "global" things
# to be really global and applied to the clicker (or any other future) dependency then use anchors
# or pass things explicitly. this felt better than using actual helm "globals"
#

appName: &_appName clabernetes

# extra labels/annotations that are added to all objects
globalAnnotations: &_globalAnnotations {}
globalLabels: &_globalLabels {}

#
# manager options
#
# the manager is the c9s controller
#
manager:
  deploymentAnnotations: {}
  deploymentLabels: {}
  podAnnotations: {}
  podLabels: {}

  imagePullPolicy: IfNotPresent

  # defaults to .Chart.Version, if 0.0.0 version defaults to 'dev-latest' tag
  image: "" # ghcr.io/srl-labs/clabernetes/clabernetes-manager:{{ .Chart.Version }}

  replicaCount: 3
  resources:
    requests:
      memory: 128Mi
      cpu: 50m
    limits: {}

  clientOperationTimeoutMultiplier: 1
  managerLogLevel: info
  controllerLogLevel: info
  inClusterDNSSuffix: svc.cluster.local

  # pod affinity settings, directly inserted into manager deployment spec; if not provided basic
  # common-sense anti-affinity is applied.
  affinity: {}


#
# launcher options
#
# the launcher is the actual "worker" pod where the nos is running/launched
#
launcher:
  imagePullPolicy: IfNotPresent

  image: "" #" ghcr.io/srl-labs/clabernetes/clabernetes-launcher:{{ .Chart.Version }}

  logLevel: info

  # default resources is a mapping of containerlab kind/type -> k8s resources/requests to apply to
  # the launcher pod(s); note that the "default" keyword under the parent "defaultResources" key
  # specifies the default/fallthrough resources -- this expects a normal looking k8s requests/limits
  # block. the "byContainerlabKind" key holds a map[string]map[string]k8sresource mapping -- the
  # outer keys are the containerlab *kind* and the inner keys *type* -- you can specify a "default"
  # key in the types level as well to just have default resources for a given kind.
  # for reference fields should be formatted like "normal" k8s resources:
  # https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#example-1
  defaultResources:
    default:
      requests:
        memory: 512Mi
        cpu: 200m
    byContainerlabKind: {}

  # imagePullThroughMode defines how the launcher pod tries to pull the image specified in the
  # topology. The options are: "auto" (default), "always", "never". The "auto" option will instruct
  # the manager to mount the CRI socket in the launcher pods, and the launcher to always try to pull
  # via the CRI first; if this fails for some reason, the launcher will try to pull via the docker
  # daemon in the launcher pod itself. "always" indicates the launcher should "always" (*only*)
  # ever pull from the CRI socket -- if the CRI is determined (by the manager) to *not* be
  # homogenous at manager start time (not all nodes in cluster are the same CRI type), then this
  # mode will cause the launcher to fail since it won't be setup to pull via the CRI (and in this
  # mode it *only* pulls via the CRI). Lastly, "never" means the launcher should only ever pull via
  # the docker daemon in the launcher pod itself (bypassing the cluster). Note that "pull through
  # mode" currently only supports containerd as a CRI.
  imagePullThroughMode: auto

#
# clicker
#
# this is an optional feature that can configure nodes in a cluster -- useful for setting things
# like ulimit and such.
#
clicker:
  enabled: false

  # pass in the "global" values to the sub chart, you can still override them, but this keeps things
  # more aligned while still being easy to override
  appName: *_appName
  globalAnnotations: *_globalAnnotations
  globalLabels: *_globalLabels

  # other values to pass to clicker go here if ya want
